# 기술 면접 주요 질문

## 자바

### 추상 클래스와 인터페이스의 공통점, 차이점 및 용도
```
[공통점]
- 추상 메서드를 가질 수 있다.
- 서브 클래스에 메서드 구현을 위임한다.
- 직접 인스턴스를 생성할 수 없다.

[차이점 및 용도]
추상 클래스
- 추상클래스는 서브 클래스들에게 공통 속성 및 메서드를 상속 해주는 용도이다.
- 클래스 변수, 인스턴스 변수를 정의할 수 있다. 메서드를 구현할 수 있다.
- 상속의 기법 중에 일반화(generalization)를 통해 추출한 수퍼 클래스를 보통 추상 클래스로 선언한다.
- 특정 기능에 대해서는 추상 메서드로 선언하여 서브 클래스에게 구현을 강요한다.

인터페이스
- 인터페이스는 사용자(caller)와 피사용자(callee) 사이의 호출 규칙을 정의할 때 사용하는 문법이다.
- 따라서 모든 메서드는 공개된 추상 메서드이다. (public abstract)
- 또한 모든 변수는 상수 이다. (public static final)
```


### 오버로딩과 오버라이딩 의미와 사용 예
```
[오버로딩(Overloading)]
- 파라미터의 타입이 다르거나 개수가 다르더라도 같은 기능을 하는 메서드에 대해 같은 이름을 부여하여
  프로그래밍의 일관성을 제공하는 것.
- 예) FileOutputStream 클래스의 write() 메서드
      write(int b), write(byte[] bytes), write(byte[] bytes, int offset, int len) 

[오버라이딩(Overriding)]
- 상속 받은 메서드를 그 클래스의 역할에 맞게 재정의 하는 것.
- 예) Object 클래스의 equals()와 hashCode(), toString() 재정의.
      toString() --> 객체의 내용을 출력하도록 재정의
      equals()   --> 같은 내용일 때 true를 리턴하도록 재정의.
      hashCode() --> 같은 내용일 때 같은 해시값을 리턴하도록 재정의. 
```

### 프리미티브 타입과 레러펀스 타입의 형변환 차이
```
[프리미티브 타입(primitive type) 형 변환]
- byte, short, char, int, long, float, double 끼리 형 변환 가능하다.
- 숫자 값을 boolean으로 또는 boolean 값을 숫자로 형 변환할 수 없다.
- 형 변환하려는 타입의 임시 메모리를 만들어 값을 저장한다.
- 큰 값을 작은 메모리에 담을 때 값이 짤릴 수 있다.

[레러펀스 타입(reference type)]
- 레퍼런스 타입의 형 변환은 인스턴스의 실제 타입을 알려주는 용도로 사용한다.
- 실제 타입이 아닌 타입으로 형 변환할 때 예외가 발생한다.
```

### 클래스 변수, 인스턴스 변수, 지역 변수
```
[클래스 변수]

```

## 데이터베이스

### 데이터, 정보, 데이터베이스, DBMS
```
[데이터]
- 현실 세계에서 관찰이나 측정을 통해 수집한 가공하지 않은 단순한 값.
- 예1) 이름, 나이, 전화번호, 이메일 등 단순 회원 데이터
- 예2) 주문 물품, 가격, 결재 유형 등 주문 데이터
- 예3) 날씨 장비를 통해 얻은 현재 습도 및 온도

[정보]
- 데이터를 가공하여 의사 결정에 도움을 줄 수 있는 형태로 만든 결과 값.
- 예1) 날씨 데이터를 계산하여 얻은 비올 확률
- 예2) 구입 데이터를 바탕으로 고객에게 추천할 제품
- 예3) 사내 게시글 등록, 조회, 답변을 통해 계산한 커뮤니케이션의 핵심 허브 역할자

[데이터베이스]
- 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임이다.

[DBMS]
- 데이터베이스를 이용하여 데이터를 저장하고 관리하는 소프트웨어이다.
- 데이터베이스에 저장된 데이터를 바탕으로 보다 효과적으로 정보를 얻을 수 있도록 돕는 역할을 한다.
```

### select, from, where, group by, having, order by 실행 순서
```
1. from       <-- 테이블 선택 
2. on         <-- 조인 조건에 일치하는 항목을 찾아
3. join       <-- 레코드와 레코드를 조인한다.
4. where      <-- 조인 결과에서 조건에 해당하는 레코드 선택한 다음
5. group by   <-- 특정 컬럼을 기준으로 값이 같은 레코드를 그룹으로 묶는다.
6. having     <-- 묶은 그룹의 값이 조건과 일치하는 것만 골라낸다.
7. select     <-- 결과에서 추출할 컬럼을 선정한다.
8. distinct   <-- 특정 컬럼을 기준으로 겹치는 레코드가 있으면 제거한다. 
9. order by   <-- 최종적으로 특정 컬럼에 대해 정렬한 다음 결과를 추출한다.
``` 

### 배열과 연결 리스트의 차이
```
[배열]
- 구현이 쉽다. 
- 연속된 메모리 공간에 값을 저장하기 때문에 순차적으로 값을 조회할 때 빠르다.
- 또한 인덱스를 이용하여 임의 위치에 바로 접근할 수 있어 검색이 빠르다.
- 단점은 값을 삽입하거나 삭제할 때 배열의 값들을 이동시켜야 하기 때문에 비효율적이다.  
- 또한 초기 생성할 때 고정 크기를 갖기 때문에 배열의 크기를 늘리거나 줄일 수 없다.

[연결 리스트]
- 배열보다 구현이 복잡하다.
- 노드와 노드 간의 연결을 통해 데이터를 저장하기 때문에 가변 크기를 갖는다.
  따라서 메모리를 효율적으로 이용할 수 있다.
- 값을 삽입하거나 삭제하기 쉽다. 
- 단점은 순차적으로 조회할 때 노드를 따라가며 값을 꺼내기 때문에 속도가 느리다.
- 또한 노드 단위로 값이 분산되어 있어 배열보다 조회 속도가 느리다. 
```

### DB 트리거란 무엇인가?
```
- 데이터를 입력하거나 삭제, 변경하기 전/후에 자동으로 실행하는 작업이다.
- 데이터 상태 관리를 자동화하는 데 사용한다.
- 예)
  데이터를 조작하기 전/후에 기록을 남기는 작업
  데이터 조작 전에 조건을 검사하여 작업의 유무를 결정하는 작업
  데이터 조작에 필요한 값을 준비시키는 작업
```

